"use strict";(self.webpackChunk_ant_design_pro_editor=self.webpackChunk_ant_design_pro_editor||[]).push([[7430],{67850:function(o,t,e){e.r(t),e.d(t,{demos:function(){return a}});var n=e(75271),a={}},52053:function(o,t,e){var n;e.r(t),e.d(t,{demos:function(){return f}});var a=e(90228),s=e.n(a),v=e(87999),l=e.n(v),d=e(75271),c=e(10549),h=e(48065),f={"docs-guide-intro-demo-columnlist":{component:d.memo(d.lazy(function(){return Promise.all([e.e(5533),e.e(2433)]).then(e.bind(e,92994))})),asset:{type:"BLOCK",id:"docs-guide-intro-demo-columnlist",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(18451).Z},"@ant-design/pro-editor":{type:"NPM",value:"1.2.1"},react:{type:"NPM",value:"18.3.1"},"./data.ts":{type:"FILE",value:e(88452).Z}},entry:"index.tsx"},context:{"@ant-design/pro-editor":c,react:n||(n=e.t(d,2)),"/home/runner/work/pro-editor/pro-editor/docs/guide/demos/ColumnList/data.ts":h},renderOpts:{compile:function(){var x=l()(s()().mark(function m(){var y,E=arguments;return s()().wrap(function(i){for(;;)switch(i.prev=i.next){case 0:return i.next=2,e.e(6495).then(e.bind(e,86495));case 2:return i.abrupt("return",(y=i.sent).default.apply(y,E));case 3:case"end":return i.stop()}},m)}));function g(){return x.apply(this,arguments)}return g}()}}}},60795:function(o,t,e){e.r(t),e.d(t,{demos:function(){return a}});var n=e(75271),a={}},42325:function(o,t,e){e.r(t),e.d(t,{demos:function(){return i}});var n=e(90228),a=e.n(n),s=e(87999),v=e.n(s),l=e(75271),d=e(10549),c=e(68339),h=e(87917),f=e(94283),x=e(35850),g=e(41750),m=e(6020),y=e(46268),E=e(97117),T=e(17062),i={"docs-guide-redo-undo-demo-redo":{component:l.memo(l.lazy(function(){return Promise.all([e.e(5533),e.e(2433)]).then(e.bind(e,83687))})),asset:{type:"BLOCK",id:"docs-guide-redo-undo-demo-redo",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(25551).Z},"@ant-design/pro-editor":{type:"NPM",value:"1.2.1"},"./store.ts":{type:"FILE",value:e(39559).Z},"./App.tsx":{type:"FILE",value:e(39682).Z},antd:{type:"NPM",value:"5.12.8"},"antd-style":{type:"NPM",value:"3.6.2"},zustand:{type:"NPM",value:"4.5.5"},"react-layout-kit":{type:"NPM",value:"1.9.0"},"./Toolbar.tsx":{type:"FILE",value:e(18807).Z},"@ant-design/icons":{type:"NPM",value:"5.4.0"}},entry:"index.tsx"},context:{"@ant-design/pro-editor":d,"/home/runner/work/pro-editor/pro-editor/docs/guide/demos/Redo/store.ts":c,"/home/runner/work/pro-editor/pro-editor/docs/guide/demos/Redo/App.tsx":h,antd:f,"antd-style":x,zustand:g,"react-layout-kit":m,"zustand/middleware":y,"/home/runner/work/pro-editor/pro-editor/docs/guide/demos/Redo/Toolbar.tsx":E,"@ant-design/icons":T},renderOpts:{compile:function(){var D=v()(a()().mark(function b(){var S,O=arguments;return a()().wrap(function(I){for(;;)switch(I.prev=I.next){case 0:return I.next=2,e.e(6495).then(e.bind(e,86495));case 2:return I.abrupt("return",(S=I.sent).default.apply(S,O));case 3:case"end":return I.stop()}},b)}));function L(){return D.apply(this,arguments)}return L}()}}}},19511:function(o,t,e){e.r(t),e.d(t,{demos:function(){return a}});var n=e(75271),a={}},14884:function(o,t,e){e.r(t),e.d(t,{demos:function(){return a}});var n=e(75271),a={}},88378:function(o,t,e){e.r(t),e.d(t,{demos:function(){return a}});var n=e(75271),a={}},29087:function(o,t,e){e.r(t),e.d(t,{demos:function(){return a}});var n=e(75271),a={}},71299:function(o,t,e){e.r(t),e.d(t,{demos:function(){return a}});var n=e(75271),a={}},85602:function(o,t,e){var n;e.r(t),e.d(t,{demos:function(){return K}});var a=e(90228),s=e.n(a),v=e(87999),l=e.n(v),d=e(75271),c=e(10549),h=e(5782),f=e(98145),x=e(41639),g=e(69472),m=e(1253),y=e(67721),E=e(17062),T=e(32154),i=e(94283),D=e(95878),L=e.n(D),b=e(3341),S=e.n(b),O=e(55116),A=e(77192),I=e.n(A),p=e(70775),z=e.n(p),B=e(6020),W=e(16665),U=e(79557),w=e(42109),K={"probuilder-demo-buttonassets":{component:d.memo(d.lazy(function(){return e.e(399).then(e.bind(e,84108))})),asset:{type:"BLOCK",id:"probuilder-demo-buttonassets",refAtomIds:["ProBuilder"],dependencies:{"index.tsx":{type:"FILE",value:e(69718).Z},"@ant-design/pro-editor":{type:"NPM",value:"1.2.1"},"./buttonAsset.ts":{type:"FILE",value:e(62177).Z},"./store.ts":{type:"FILE",value:e(63693).Z},"./models.ts":{type:"FILE",value:e(82522).Z},"./_Component.tsx":{type:"FILE",value:e(36893).Z},"./_Panel.tsx":{type:"FILE",value:e(99563).Z},"./codeEmitter.tsx":{type:"FILE",value:e(77004).Z},"@ant-design/icons":{type:"NPM",value:"5.4.0"},"@ant-design/leva-panel":{type:"NPM",value:"1.0.0"},antd:{type:"NPM",value:"5.12.8"},"lodash.template":{type:"NPM",value:"4.5.0"},"fast-deep-equal":{type:"NPM",value:"3.1.3"},react:{type:"NPM",value:"18.3.1"},"./format.ts":{type:"FILE",value:e(82147).Z},prettier:{type:"NPM",value:"2.8.8"},"react-layout-kit":{type:"NPM",value:"1.9.0"},zustand:{type:"NPM",value:"4.5.5"}},entry:"index.tsx"},context:{"@ant-design/pro-editor":c,"/home/runner/work/pro-editor/pro-editor/docs/pro-editor/demos/buttonAsset/index.ts":h,"/home/runner/work/pro-editor/pro-editor/docs/pro-editor/demos/buttonAsset/store.ts":f,"/home/runner/work/pro-editor/pro-editor/docs/pro-editor/demos/buttonAsset/models.ts":x,"/home/runner/work/pro-editor/pro-editor/docs/pro-editor/demos/buttonAsset/_Component.tsx":g,"/home/runner/work/pro-editor/pro-editor/docs/pro-editor/demos/buttonAsset/_Panel.tsx":m,"/home/runner/work/pro-editor/pro-editor/docs/pro-editor/demos/buttonAsset/codeEmitter.tsx":y,"@ant-design/icons":E,"@ant-design/leva-panel":T,antd:i,"lodash.template":D,"fast-deep-equal":b,react:n||(n=e.t(d,2)),"/home/runner/work/pro-editor/pro-editor/docs/pro-editor/demos/buttonAsset/format.ts":O,prettier:A,"prettier/parser-typescript":p,"react-layout-kit":B,"zustand/shallow":W},renderOpts:{compile:function(){var P=l()(s()().mark(function C(){var u,M=arguments;return s()().wrap(function(r){for(;;)switch(r.prev=r.next){case 0:return r.next=2,e.e(6495).then(e.bind(e,86495));case 2:return r.abrupt("return",(u=r.sent).default.apply(u,M));case 3:case"end":return r.stop()}},C)}));function _(){return P.apply(this,arguments)}return _}()}},"probuilder-demo-defaultassets":{component:d.memo(d.lazy(function(){return e.e(399).then(e.bind(e,9199))})),asset:{type:"BLOCK",id:"probuilder-demo-defaultassets",refAtomIds:["ProBuilder"],dependencies:{"index.tsx":{type:"FILE",value:e(28536).Z},"@ant-design/pro-editor":{type:"NPM",value:"1.2.1"}},entry:"index.tsx"},context:{"@/ComponentAsset/demoAssets":U,"@ant-design/pro-editor":c},renderOpts:{compile:function(){var P=l()(s()().mark(function C(){var u,M=arguments;return s()().wrap(function(r){for(;;)switch(r.prev=r.next){case 0:return r.next=2,e.e(6495).then(e.bind(e,86495));case 2:return r.abrupt("return",(u=r.sent).default.apply(u,M));case 3:case"end":return r.stop()}},C)}));function _(){return P.apply(this,arguments)}return _}()}},"probuilder-demo-empty":{component:d.memo(d.lazy(function(){return e.e(399).then(e.bind(e,7714))})),asset:{type:"BLOCK",id:"probuilder-demo-empty",refAtomIds:["ProBuilder"],dependencies:{"index.tsx":{type:"FILE",value:e(60664).Z},"@ant-design/pro-editor":{type:"NPM",value:"1.2.1"}},entry:"index.tsx"},context:{"@ant-design/pro-editor":c},renderOpts:{compile:function(){var P=l()(s()().mark(function C(){var u,M=arguments;return s()().wrap(function(r){for(;;)switch(r.prev=r.next){case 0:return r.next=2,e.e(6495).then(e.bind(e,86495));case 2:return r.abrupt("return",(u=r.sent).default.apply(u,M));case 3:case"end":return r.stop()}},C)}));function _(){return P.apply(this,arguments)}return _}()}},"probuilder-demo-controlledpresence":{component:d.memo(d.lazy(function(){return e.e(399).then(e.bind(e,64922))})),asset:{type:"BLOCK",id:"probuilder-demo-controlledpresence",refAtomIds:["ProBuilder"],dependencies:{"index.tsx":{type:"FILE",value:e(36633).Z},"@ant-design/pro-editor":{type:"NPM",value:"1.2.1"},ahooks:{type:"NPM",value:"3.7.8"},"react-layout-kit":{type:"NPM",value:"1.9.0"}},entry:"index.tsx"},context:{"@/ComponentAsset/demoAssets":U,"@/index":c,"@ant-design/pro-editor":c,ahooks:w,"react-layout-kit":B},renderOpts:{compile:function(){var P=l()(s()().mark(function C(){var u,M=arguments;return s()().wrap(function(r){for(;;)switch(r.prev=r.next){case 0:return r.next=2,e.e(6495).then(e.bind(e,86495));case 2:return r.abrupt("return",(u=r.sent).default.apply(u,M));case 3:case"end":return r.stop()}},C)}));function _(){return P.apply(this,arguments)}return _}()}}}},13610:function(o,t,e){e.r(t),e.d(t,{demos:function(){return a}});var n=e(75271),a={}},54026:function(o,t,e){var n;e.r(t),e.d(t,{demos:function(){return D}});var a=e(90228),s=e.n(a),v=e(87999),l=e.n(v),d=e(75271),c=e(10549),h=e(94283),f=e(20742),x=e(89437),g=e(20173),m=e(3341),y=e.n(m),E=e(24505),T=e(91555),i=e(79258),D={"docs-pro-editor-realtime-collaboration-demo-demo":{component:d.memo(d.lazy(function(){return Promise.all([e.e(5533),e.e(2433)]).then(e.bind(e,71294))})),asset:{type:"BLOCK",id:"docs-pro-editor-realtime-collaboration-demo-demo",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(47835).Z},"@ant-design/pro-editor":{type:"NPM",value:"1.2.1"},antd:{type:"NPM",value:"5.12.8"},react:{type:"NPM",value:"18.3.1"},"y-webrtc":{type:"NPM",value:"10.3.0"},"./store.ts":{type:"FILE",value:e(27410).Z},"./SessionForm.tsx":{type:"FILE",value:e(59893).Z},"fast-deep-equal":{type:"NPM",value:"3.1.3"},yjs:{type:"NPM",value:"13.6.18"},"zustand-utils":{type:"NPM",value:"1.3.2"},zustand:{type:"NPM",value:"4.5.5"}},entry:"index.tsx",description:'\u6253\u5F00\u591A\u4E2A\u7A97\u53E3\uFF0C\u70B9\u51FB "Join" \u52A0\u5165\u534F\u4F5C',title:"\u5B9E\u65F6\u534F\u540C"},context:{"@ant-design/pro-editor":c,antd:h,react:n||(n=e.t(d,2)),"y-webrtc":f,"/home/runner/work/pro-editor/pro-editor/docs/pro-editor/demos/realtimeCollaboration/store.ts":x,"/home/runner/work/pro-editor/pro-editor/docs/pro-editor/demos/realtimeCollaboration/SessionForm.tsx":g,"fast-deep-equal":m,yjs:E,"zustand-utils":T,"zustand/traditional":i},renderOpts:{compile:function(){var L=l()(s()().mark(function S(){var O,A=arguments;return s()().wrap(function(p){for(;;)switch(p.prev=p.next){case 0:return p.next=2,e.e(6495).then(e.bind(e,86495));case 2:return p.abrupt("return",(O=p.sent).default.apply(O,A));case 3:case"end":return p.stop()}},S)}));function b(){return L.apply(this,arguments)}return b}()}}}},59100:function(o,t,e){e.r(t),e.d(t,{demos:function(){return a}});var n=e(75271),a={}},33573:function(o,t,e){e.r(t),e.d(t,{demos:function(){return a}});var n=e(75271),a={}},15893:function(o,t,e){e.r(t),e.d(t,{texts:function(){return n}});const n=[{value:"The editor scenario is different from the CRUD web page, as it involves a large amount of rich interactive capabilities. Therefore, it is crucial to design a data flow architecture that is easy to develop and maintain.",paraId:0,tocIndex:0},{value:"Conceptual Term",paraId:1,tocIndex:1},{value:"Explanation",paraId:1,tocIndex:1},{value:"store",paraId:1,tocIndex:1},{value:"The store contains the application's state and actions. It allows access to and modification of the state during application rendering.",paraId:1,tocIndex:1},{value:"state",paraId:1,tocIndex:1},{value:"The state refers to the application's data, storing the current state of the application. Any change in the state will trigger a re-rendering of the application to reflect the new state.",paraId:1,tocIndex:1},{value:"action",paraId:1,tocIndex:1},{value:"An action is an operation function that describes the interactive events occurring in the application. Actions are typically triggered by user interactions, network requests, or timers. Actions can be ",paraId:1,tocIndex:1},{value:"synchronous",paraId:1,tocIndex:1},{value:" or ",paraId:1,tocIndex:1},{value:"asynchronous",paraId:1,tocIndex:1},{value:".",paraId:1,tocIndex:1},{value:"reducer",paraId:1,tocIndex:1},{value:"A reducer is a pure function that takes the current state and action as parameters and returns a new state. It is used to update the application's state based on the action type. A reducer is a pure function with no side effects, and therefore, it is always a ",paraId:1,tocIndex:1},{value:"synchronous",paraId:1,tocIndex:1},{value:" function.",paraId:1,tocIndex:1},{value:"selector",paraId:1,tocIndex:1},{value:"A selector is a function used to retrieve specific data from the application's state. It takes the application's state as a parameter and returns computed or transformed data. Selectors can combine parts of the state or multiple states to generate derived data. Selectors are commonly used to map the application's state to component props for component use.",paraId:1,tocIndex:1},{value:"slice",paraId:1,tocIndex:1},{value:"A slice is a concept used to express a part of the data model's state. It specifies a state slice and its related state, action, reducer, and selector. Using slices, a large store can be divided into smaller, maintainable subtypes.",paraId:1,tocIndex:1},{value:"In different levels of complexity, the organization of the store structure can vary significantly:",paraId:2,tocIndex:2},{value:"Generally includes 2 to 5 states and 3 to 4 actions. The structure at this level typically consists of a single ",paraId:3,tocIndex:3},{value:"store.ts",paraId:3,tocIndex:3},{value:" file and a ",paraId:3,tocIndex:3},{value:"initialState.ts",paraId:3,tocIndex:3},{value:" file.",paraId:3,tocIndex:3},{value:`DataFill/store
\u251C\u2500\u2500 index.ts
\u251C\u2500\u2500 initialState.ts
`,paraId:4,tocIndex:3},{value:"Moderate complexity involves 5 to 15 states, 5 to 10 actions, and may include selector implementation for derived states. It may also involve reducer simplifying part of the data changes. The structure at this level generally consists of a ",paraId:5,tocIndex:4},{value:"store.ts",paraId:5,tocIndex:4},{value:", ",paraId:5,tocIndex:4},{value:"initialState.ts",paraId:5,tocIndex:4},{value:", and ",paraId:5,tocIndex:4},{value:"selectors.ts",paraId:5,tocIndex:4},{value:"/",paraId:5,tocIndex:4},{value:"reducer.ts",paraId:5,tocIndex:4},{value:".",paraId:5,tocIndex:4},{value:`IconPicker/store
\u251C\u2500\u2500 index.ts
\u251C\u2500\u2500 initialState.ts
\u251C\u2500\u2500 selectors.ts
\u2514\u2500\u2500 store.ts
`,paraId:6,tocIndex:4},{value:`SortableList/store
\u251C\u2500\u2500 index.ts
\u251C\u2500\u2500 initialState.ts
\u251C\u2500\u2500 listDataReducer.ts
\u2514\u2500\u2500 store.ts
`,paraId:7,tocIndex:4},{value:"Medium complexity involves 15 to 30 states, 10 to 20 actions, and likely includes selectors to aggregate derived states and reducers to simplify part of the data changes.",paraId:8,tocIndex:5},{value:"At this level, using a single action store for management becomes challenging, and it often requires breaking it down into multiple slices to manage different actions.",paraId:9,tocIndex:5},{value:"The following code represents the internal data flow of the ",paraId:10,tocIndex:5},{value:"SortableTree",paraId:10,tocIndex:5},{value:" component:",paraId:10,tocIndex:5},{value:`SortableTree/store
\u251C\u2500\u2500 index.ts
\u251C\u2500\u2500 initialState.ts
\u251C\u2500\u2500 selectors.ts
\u251C\u2500\u2500 slices
   \u251C\u2500\u2500 crudSlice.ts
   \u251C\u2500\u2500 dndSlice.ts
   \u2514\u2500\u2500 selectionSlice.ts
\u251C\u2500\u2500 store.ts
\u2514\u2500\u2500 treeDataReducer.ts
`,paraId:11,tocIndex:5},{value:"Interpreting key files:",paraId:12,tocIndex:5},{value:"selectors.ts",paraId:13,tocIndex:5},{value:": Contains selector functions used to retrieve derived states from the store. Selector functions can aggregate and compute derived states as needed, providing them to components for use.",paraId:13,tocIndex:5},{value:"slices folder",paraId:13,tocIndex:5},{value:`: Multiple modules extracted for managing different actions. Each module generally includes a Slice containing related actions.
`,paraId:13,tocIndex:5},{value:"crudSlice.ts",paraId:14,tocIndex:5},{value:": Manages operations for CRUD operations on tree data.",paraId:14,tocIndex:5},{value:"dndSlice.ts",paraId:14,tocIndex:5},{value:": Manages drag and drop-related operations.",paraId:14,tocIndex:5},{value:"selectionSlice.ts",paraId:14,tocIndex:5},{value:": Manages operations related to selected states.",paraId:14,tocIndex:5},{value:"treeDataReducer.ts",paraId:13,tocIndex:5},{value:": Manages the reducer for tree data. It handles atomic operations related to data changes in ",paraId:13,tocIndex:5},{value:"treeData",paraId:13,tocIndex:5},{value:", such as adding nodes, deleting nodes, and dragging nodes.",paraId:13,tocIndex:5},{value:"High complexity involves over 30 states and over 20 actions. It inevitably requires slices for modular cohesion. Each slice declares its own initState, action, reducer, and selector.",paraId:15,tocIndex:6},{value:"Below is an example of a high-complexity data flow (",paraId:16,tocIndex:6},{value:"link",paraId:16,tocIndex:6},{value:"):",paraId:16,tocIndex:6},{value:`LobeChat SessionStore
\u251C\u2500\u2500 index.ts
\u251C\u2500\u2500 initialState.ts
\u251C\u2500\u2500 selectors.ts
\u251C\u2500\u2500 slices
\u2502   \u251C\u2500\u2500 agentConfig
\u2502   \u2502   \u251C\u2500\u2500 action.ts
\u2502   \u2502   \u251C\u2500\u2500 index.ts
\u2502   \u2502   \u251C\u2500\u2500 initialState.ts
\u2502   \u2502   \u2514\u2500\u2500 selectors.ts
\u2502   \u251C\u2500\u2500 chat
\u2502   \u2502   \u251C\u2500\u2500 actions
\u2502   \u2502   \u2502   \u251C\u2500\u2500 index.ts
\u2502   \u2502   \u2502   \u251C\u2500\u2500 message.ts
\u2502   \u2502   \u2502   \u2514\u2500\u2500 topic.ts
\u2502   \u2502   \u251C\u2500\u2500 index.ts
\u2502   \u2502   \u251C\u2500\u2500 initialState.ts
\u2502   \u2502   \u251C\u2500\u2500 reducers
\u2502   \u2502   \u2502   \u251C\u2500\u2500 message.ts
\u2502   \u2502   \u2502   \u2514\u2500\u2500 topic.ts
\u2502   \u2502   \u251C\u2500\u2500 selectors
\u2502   \u2502   \u2502   \u251C\u2500\u2500 chat.ts
\u2502   \u2502   \u2502   \u251C\u2500\u2500 index.ts
\u2502   \u2502   \u2502   \u251C\u2500\u2500 token.ts
\u2502   \u2502   \u2502   \u251C\u2500\u2500 topic.ts
\u2502   \u2502   \u2502   \u2514\u2500\u2500 utils.ts
\u2502   \u2502   \u2514\u2500\u2500 utils.ts
\u2502   \u2514\u2500\u2500 session
\u2502       \u251C\u2500\u2500 action.ts
\u2502       \u251C\u2500\u2500 index.ts
\u2502       \u251C\u2500\u2500 initialState.ts
\u2502       \u251C\u2500\u2500 reducers
\u2502       \u2502   \u2514\u2500\u2500 session.ts
\u2502       \u2514\u2500\u2500 selectors
\u2502           \u251C\u2500\u2500 export.ts
\u2502           \u251C\u2500\u2500 index.ts
\u2502           \u2514\u2500\u2500 list.ts
\u2514\u2500\u2500 store.ts
`,paraId:17,tocIndex:6},{value:"Although the directory structure of this data flow seems complex, with the modularization of slices and fractal architecture, it becomes easy to locate the corresponding modules, making it easy to maintain and add new features.",paraId:18,tocIndex:6},{value:"In the editor scenario, we should assume that it will eventually evolve into a high-complexity data flow. Therefore, from the beginning, the directory structure should be split into slices, with each slice being an independent module containing its own initState, action, reducer, and selector.",paraId:19,tocIndex:7},{value:`editorStore
\u251C\u2500\u2500 index.ts
\u251C\u2500\u2500 initialState.ts
\u251C\u2500\u2500 selectors.ts
\u251C\u2500\u2500 slices
\u2502   \u251C\u2500\u2500 crud
\u2502   \u2502   \u251C\u2500\u2500 action.ts
\u2502   \u2502   \u251C\u2500\u2500 index.ts
\u2502   \u2502   \u251C\u2500\u2500 initialState.ts
\u2502   \u2502   \u2514\u2500\u2500 selectors.ts
\u2514\u2500\u2500 store.ts
`,paraId:20,tocIndex:7},{value:"index.ts",paraId:21,tocIndex:8},{value:" is an aggregate export file and will not be elaborated further.",paraId:21,tocIndex:8},{value:"initialState.ts",paraId:22,tocIndex:9},{value:" aggregates all slice initialStates.",paraId:22,tocIndex:9},{value:`import { CRUDState, initialCRUDState } from './slices/crud';

export type EditorStoreState = CRUDState & AnotherState;

export const initialState: EditorStoreState = {
  ...initialCRUDState,
};
`,paraId:23,tocIndex:9},{value:"If later expanded to multiple slices, simply aggregate and export the corresponding state in the same way.",paraId:24,tocIndex:9},{value:"Selectors are exported from their respective slices for direct external use.",paraId:25,tocIndex:10},{value:`export { crudSelectors } from './slices/crud';
export { chatSelectors, topicSelectors } from './slices/chat';
export { sessionSelectors } from './slices/session';
`,paraId:26,tocIndex:10},{value:"Now, let's take a look at ",paraId:27,tocIndex:11},{value:"store.ts",paraId:27,tocIndex:11},{value:".",paraId:27,tocIndex:11},{value:`import { devtools } from 'zustand/middleware';
import { shallow } from 'zustand/shallow';
import { createWithEqualityFn } from 'zustand/traditional';
import { StateCreator } from 'zustand/vanilla';

import { EditorStoreState, initialState } from './initialState';
import { CRUDAction, createCRUDSlice } from './slices/crud';

//  ===============  Aggregate createStoreFn ============ //

export type EditorStore = CRUDAction & EditorStoreState;

const createStore: StateCreator<EditorStore, [['zustand/devtools', never]]> = (...parameters) => ({
  ...initialState,
  ...createCRUDSlice(...parameters),
});

//  ===============  Implement useStore ============ //

export const useEditorStore = createWithEqualityFn<EditorStore>()(
  devtools(createStore, {
    name: 'EditorStore',
  }),

  shallow,
);
`,paraId:28,tocIndex:11},{value:"The key code here is ",paraId:29,tocIndex:11},{value:"createStore",paraId:29,tocIndex:11},{value:", which aggregates all slices and returns a complete editor Store for store initialization.",paraId:29,tocIndex:11},{value:"The ",paraId:30,tocIndex:11},{value:"createWithEqualityFn",paraId:30,tocIndex:11},{value:" function wraps relevant middleware, and by default, it uses the ",paraId:30,tocIndex:11},{value:"devtools",paraId:30,tocIndex:11},{value:" middleware to provide developer tool support and replaces the default comparison function with ",paraId:30,tocIndex:11},{value:"shallow",paraId:30,tocIndex:11},{value:" to optimize performance.",paraId:30,tocIndex:11},{value:"The initState and selector in each slice are similar to non-slice. Therefore, they will not be elaborated further. Let's focus on ",paraId:31,tocIndex:12},{value:"slices/crud/action.ts",paraId:31,tocIndex:12},{value:":",paraId:31,tocIndex:12},{value:`import { StateCreator } from 'zustand/vanilla';

import { EditorStore } from '@/store/edtior';

export interface CrudAction {
  // Relevant business actions...
}

export const createCrudSlice: StateCreator<
  EditorStore,
  [['zustand/devtools', never]],
  [],
  CrudAction
> = (set, get) => ({
  // ...
});
`,paraId:32,tocIndex:12},{value:"Through the ",paraId:33,tocIndex:12},{value:"import",paraId:33,tocIndex:12},{value:" statement, the code then defines a ",paraId:33,tocIndex:12},{value:"CrudAction",paraId:33,tocIndex:12},{value:" interface to describe business operations.",paraId:33,tocIndex:12},{value:"The ",paraId:34,tocIndex:12},{value:"createCrudSlice",paraId:34,tocIndex:12},{value:" is declared as a function that takes ",paraId:34,tocIndex:12},{value:"set",paraId:34,tocIndex:12},{value:" and ",paraId:34,tocIndex:12},{value:"get",paraId:34,tocIndex:12},{value:" as parameters and returns an object containing the editor state and business operations.",paraId:34,tocIndex:12},{value:`StateCreator<EditorStore, [['zustand/devtools', never]], [], CrudAction>;
`,paraId:35,tocIndex:12},{value:"The type definition introduces ",paraId:36,tocIndex:12},{value:"StateCreator",paraId:36,tocIndex:12},{value:" as the full type, and ",paraId:36,tocIndex:12},{value:"CrudAction",paraId:36,tocIndex:12},{value:" at the end represents the actions that need to be implemented in this slice. The middle ",paraId:36,tocIndex:12},{value:"[['zustand/devtools', never]]",paraId:36,tocIndex:12},{value:" indicates that this slice is wrapped by the ",paraId:36,tocIndex:12},{value:"devtools",paraId:36,tocIndex:12},{value:" middleware, allowing the ",paraId:36,tocIndex:12},{value:"set",paraId:36,tocIndex:12},{value:" method to accept middleware parameters.",paraId:36,tocIndex:12},{value:"This implementation ensures that each slice has the ability to perceive all states and call all methods, while focusing only on its defined methods and states, thus achieving convergence of focus.",paraId:37,tocIndex:12},{value:"With the slice layering pattern, we can ensure that each slice's functional modules are controllable and do not expand indefinitely. They can be split into common, business, or internal slices as needed.",paraId:38,tocIndex:13},{value:"Once the framework is controllable, we can focus on feature development. The core feature development workload exists in two areas: action and selector. Let's first discuss the action part.",paraId:39,tocIndex:13},{value:"Actions, being ordinary function methods, support both synchronous and asynchronous operations in theory. However, based on our past practical experience, actions can be divided into two categories:",paraId:40,tocIndex:14},{value:"Data state changes: For example, modifying the current user's status information, modifying login status, marking viewed guides, etc.",paraId:41,tocIndex:14},{value:"Business logic orchestration: For example, a login process includes requests, success judgment, failure judgment, etc.",paraId:41,tocIndex:14},{value:"We strongly recommend consolidating the first category of data state changes into a single ",paraId:42,tocIndex:14},{value:"dispatchXXX",paraId:42,tocIndex:14},{value:" method and sinking the data change logic into a reducer. In SortableTree, a ",paraId:42,tocIndex:14},{value:"dispatchTreeData",paraId:42,tocIndex:14},{value:" method is consolidated:",paraId:42,tocIndex:14},{value:`const crudSlice = (set, get) => ({
  dispatchTreeData: (payload) => {
    const { treeData } = get();
    const nextTreeData = treeDataReducer(treeData, payload);

    set({ treeData: nextTreeData });
  },
});
`,paraId:43,tocIndex:14},{value:"The benefit of this approach is to ensure the atomicity of data changes. By sinking the data change logic into a reducer, it can prevent the logic from being scattered across various actions, leading to uncontrolled data changes.",paraId:44,tocIndex:14},{value:"This approach also brings several benefits:",paraId:45,tocIndex:14},{value:"Facilitates controlled capability",paraId:46,tocIndex:14},{value:": After atomic data changes, by adding an ",paraId:46,tocIndex:14},{value:"onTreeDataChange",paraId:46,tocIndex:14},{value:" at the bottom of ",paraId:46,tocIndex:14},{value:"dispatchTreeData",paraId:46,tocIndex:14},{value:", it can easily achieve controlled data state changes, making it easy to transform the application into a component.",paraId:46,tocIndex:14},{value:"Semantic data changes",paraId:46,tocIndex:14},{value:": By naming the dispatch corresponding payload methods, it can easily make the originally difficult data changes semantic. For example, ",paraId:46,tocIndex:14},{value:"dispatchTreeData({ type: 'toggleCollapse', id:'123' })",paraId:46,tocIndex:14},{value:" can be easily understood as expanding/collapsing the node with id 123.",paraId:46,tocIndex:14},{value:"Enhances state maintainability",paraId:46,tocIndex:14},{value:": After unifying the dispatch of data changes, we can easily change the state by calling dispatch outside the store or inside the store, significantly reducing maintenance costs.",paraId:46,tocIndex:14},{value:"In addition, sinking the data change logic into a reducer brings corresponding benefits. Since a reducer is just a pure function, it can easily implement unit testing. Combined with AI, we can achieve one-line requirement implementation of reducers and generate test code with a single click. The development and maintenance costs of reducers will be greatly reduced.",paraId:47,tocIndex:15},{value:"Feature Implementation",paraId:48,tocIndex:15},{value:"Unit Testing",paraId:48,tocIndex:15},{value:"Selectors are generally used to map the data stored in the store to the content needed for display on the page. Therefore, the data stored in the store can be transformed through selectors. For example:",paraId:49,tocIndex:16},{value:`import { currentChats, getChatsById } from './chat';
import { chatsTokenCount, systemRoleTokenCount, totalTokenCount } from './token';

export const chatSelectors = {
  chatsTokenCount,
  currentChats,
  getChatsById,
  systemRoleTokenCount,
  totalTokenCount,
};
`,paraId:50,tocIndex:16},{value:"Where ",paraId:51,tocIndex:16},{value:"chatsTokenCount",paraId:51,tocIndex:16},{value:" is a selector, aimed at calculating the token count in messages. It transforms the ",paraId:51,tocIndex:16},{value:"chats",paraId:51,tocIndex:16},{value:" array in the store into a numerical value for external use.",paraId:51,tocIndex:16},{value:`export const chatsTokenCount = (s: SessionStore): number[] => {
  const chats = currentChatsWithHistoryConfig(s);
  return encode(chats.map((m) => m.content).join('')).length;
};
`,paraId:52,tocIndex:16},{value:"Since a selector is just a function, it can also be easily integrated with simple unit testing.",paraId:53,tocIndex:16},{value:"Using a selector on the page is also straightforward, simply import it as needed. Since the transformed data type is ",paraId:54,tocIndex:16},{value:"number",paraId:54,tocIndex:16},{value:", the state type perceived by React is also ",paraId:54,tocIndex:16},{value:"number",paraId:54,tocIndex:16},{value:". Therefore, even if there are other state changes in ",paraId:54,tocIndex:16},{value:"chats",paraId:54,tocIndex:16},{value:" that do not affect the calculation result (such as updating the message time), the component will not trigger a re-render.",paraId:54,tocIndex:16},{value:`const Token = memo<>(() => {
  const [totalToken, systemRoleToken, chatsToken] = useSessionStore((s) => [
    chatSelectors.totalTokenCount(s),
    chatSelectors.systemRoleTokenCount(s),
    chatSelectors.chatsTokenCount(s),
  ]);

  return (
    <Tooltip placement={'bottom'} title={('tokenDetail', { chatsToken, systemRoleToken })}>
      <TokenTag value={totalToken + inputTokenCount} />
    </Tooltip>
  );
});
`,paraId:55,tocIndex:16}]},66500:function(o,t,e){e.r(t),e.d(t,{texts:function(){return n}});const n=[{value:'ProEditor is positioned as an editor UI framework, aiming to provide rich and easy-to-use basic components and atomic capabilities for the "editing" scenario.',paraId:0,tocIndex:0},{value:`# @ant-design/pro-editor is based on antd and antd-style, and needs to be installed in the project
$ npm install antd antd-style -S
$ npm install @ant-design/pro-editor -S
`,paraId:1,tocIndex:1},{value:'ProEditor provides a series of components optimized for the "editing" scenario, including but not limited to "SortableList", "SortableTree", "DraggablePanel", "Highlight", "ContextMenu", and more. For complete component documentation, please refer to: ',paraId:2,tocIndex:2},{value:"Basic Components",paraId:3,tocIndex:2},{value:"Below is a typical array object editing scenario. Our provided ColumnList can help developers quickly implement a high-quality array editing component.",paraId:4,tocIndex:2},{value:"Initially, ProEditor was positioned as a visual configuration framework for components. Therefore, ProEditor provides a series of containers and atomic components for visual component assembly, helping developers quickly implement a visual configuration component.",paraId:5,tocIndex:3},{value:"See: ",paraId:6,tocIndex:3},{value:"ProEditor Assembler Container",paraId:7,tocIndex:3},{value:"ProEditor supports tree shaking based on ES modules by default. Directly importing ",paraId:8,tocIndex:5},{value:"import { ActionIcon } from '@ant-design/pro-editor';",paraId:8,tocIndex:5},{value:" will achieve on-demand loading.",paraId:8,tocIndex:5},{value:"ProEditor is developed using TypeScript, thus providing complete type definitions.",paraId:9,tocIndex:6}]},62478:function(o,t,e){e.r(t),e.d(t,{texts:function(){return n}});const n=[{value:"Next.js",paraId:0,tocIndex:0},{value:" is a very popular development framework in the community, and integrating ProEditor with Next.js is very easy.",paraId:0,tocIndex:0},{value:`npx create-next-app@latest
`,paraId:1,tocIndex:0},{value:`npm install @ant-design/pro-editor --save
or
pnpm install @ant-design/pro-editor
`,paraId:2,tocIndex:1},{value:"Since Next.js is a CSR/SSR isomorphic React framework, and ProChat only provides esm modules by default, after installation, you need to add relevant dependencies to ",paraId:3,tocIndex:1},{value:"transpilePackages",paraId:3,tocIndex:1},{value:" in ",paraId:3,tocIndex:1},{value:"next.config.(m)js",paraId:3,tocIndex:1},{value:":",paraId:3,tocIndex:1},{value:"In the latest version of NextJS 14 AppRoute, this configuration is no longer needed",paraId:4,tocIndex:1},{value:`/** @type {import('next').NextConfig} */
const nextConfig = {
  // Convert pure esm modules to node-compatible modules
  transpilePackages: ['@ant-design/pro-editor'],
};
`,paraId:5,tocIndex:1},{value:"Taking the ",paraId:6,tocIndex:2},{value:"SortableList",paraId:6,tocIndex:2},{value:" component as an example, if it is a project created by the default scaffolding, you can simply write the following code in ",paraId:6,tocIndex:2},{value:"page.js|tsx",paraId:6,tocIndex:2},{value:" to see it in action.",paraId:6,tocIndex:2},{value:`'use client';
import type { ColumnItemList } from '@ant-design/pro-editor';
import { ColumnList } from '@ant-design/pro-editor';
import { useState } from 'react';

const tableColumnValueOptions = [
  // ... (omitted for brevity)
];

type SchemaItem = {
  title: string,
  valueType: string,
  dataIndex: string,
};

const INIT_VALUES = [
  // ... (omitted for brevity)
];

const columns: ColumnItemList<SchemaItem> = [
  // ... (omitted for brevity)
];

export default () => {
  const [value, setValue] = useState(INIT_VALUES);

  return (
    <ColumnList
      columns={columns}
      value={value}
      onChange={(values) => {
        setValue(values);
        console.log('onChange', values);
      }}
    />
  );
};
`,paraId:7,tocIndex:2}]},23919:function(o,t,e){e.r(t),e.d(t,{texts:function(){return n}});const n=[{value:"Undo redo is an important feature to ensure user experience in the editor scenario. As an editor framework, ProEditor provides atomic capabilities for undo and redo for upper-level application editors.",paraId:0,tocIndex:0},{value:"Wrap ProEditorProvider with the outer layer and pass in the corresponding zustand store",paraId:1,tocIndex:3},{value:`import { ProEditorProvider } from '@ant-design/pro-editor';

import { useStore } from './store';

export default () => {
  return (
    <ProEditorProvider store={[useStore]}>
      <App />
    </ProEditorProvider>
  );
};
`,paraId:2,tocIndex:3},{value:"Wrap zustand store with ProEditorMiddleware",paraId:3,tocIndex:3},{value:`import { proEditorMiddleware, ProEditorOptions } from '@ant-design/pro-editor';

interface ProEditorStore extends Partial<Store> { }


const proEditorOptions: ProEditorOptions<Store, ProEditorStore> = {
  name: 'store-name', // Each store needs to have its own unique name
  partialize: (s) => ({ data: s.data }), // Support on-demand access
};

export const useStore = create<Store>()(

  // createStore is an object of type StoreCreator
  proEditorMiddleware(createStore, proEditorOptions)),
);
`,paraId:4,tocIndex:3},{value:"Usage with multiple stores:",paraId:5,tocIndex:3},{value:`import { ProEditorProvider } from '@ant-design/pro-editor';

import { useAStore } from './storeA';
import { useBStore } from './storeB';

export default () => {
  return (
    <ProEditorProvider store={[useAStore, useBStore]}>
      <App />
    </ProEditorProvider>
  );
};
`,paraId:6,tocIndex:3},{value:"Isolation of undo and redo for multiple stores:",paraId:7,tocIndex:3},{value:`<div>
  <ProEditorProvider store={[cStore]}>
    <A />
  </ProEditorProvider>

  <ProEditorProvider store={[dStore]}>
    <B />
  </ProEditorProvider>
</div>
`,paraId:8,tocIndex:3},{value:`const createStore: StateCreator<Store, [['zustand/devtools', never], ['pro-editor', never]]> = (
  set,
  get,
) => ({
  tabs: '1',
  switchTabs: (key) => {
    set({ tabs: key });
  },
  plusWithoutHistory: () => {
    set((s) => ({ ...s, data: s.data + 2 }), false, {
      type: 'plusWithoutHistory',
      // Does not enter the history
      recordHistory: false,
    });
  },

  plus: () => {
    const nextData = get().data + 1;

    // Enters the history by default
    set({ data: nextData }, false, { type: 'plus' });
  },
  data: 3,
});
`,paraId:9,tocIndex:4}]},82795:function(o,t,e){e.r(t),e.d(t,{texts:function(){return n}});const n=[{value:"In the development scene of the middle and back office, ",paraId:0,tocIndex:0},{value:"umi",paraId:0,tocIndex:0},{value:" is a very good choice. Integrating ",paraId:0,tocIndex:0},{value:"ProEditor",paraId:0,tocIndex:0},{value:" with ",paraId:0,tocIndex:0},{value:"umi",paraId:0,tocIndex:0},{value:" is very easy. After installation, you can use it directly.",paraId:0,tocIndex:0},{value:`npx create-umi@latest
or
yarn create umi
pnpm dlx create-umi@latest
`,paraId:1,tocIndex:0},{value:"After creating it",paraId:2,tocIndex:1},{value:`npm install @ant-design/pro-editor --save
or
pnpm install @ant-design/pro-editor
`,paraId:3,tocIndex:1},{value:`import type { ColumnItemList } from '@ant-design/pro-editor';
import { ColumnList } from '@ant-design/pro-editor';
import { useState } from 'react';

const tableColumnValueOptions = [
  { label: 'index', value: 'index' },
  { label: 'indexBorder', value: 'indexBorder' },
  { label: 'digit', value: 'digit' },
  { label: 'password', value: 'password' },
  { label: 'money', value: 'money' },
  { label: 'text', value: 'text' },
  { label: 'textarea', value: 'textarea' },
  { label: 'date', value: 'date' },
  { label: 'option', value: 'option' },
  { label: 'dateTime', value: 'dateTime' },
  { label: 'dateWeek', value: 'dateWeek' },
  { label: 'dateMonth', value: 'dateMonth' },
  { label: 'dateQuarter', value: 'dateQuarter' },
  { label: 'dateYear', value: 'dateYear' },
  { label: 'dateRange', value: 'dateRange' },
  { label: 'dateTimeRange', value: 'dateTimeRange' },
  { label: 'time', value: 'time' },
  { label: 'timeRange', value: 'timeRange' },
  { label: 'select', value: 'select' },
  { label: 'checkbox', value: 'checkbox' },
  { label: 'rate', value: 'rate' },
  { label: 'radio', value: 'radio' },
  { label: 'radioButton', value: 'radioButton' },
  { label: 'progress', value: 'progress' },
  { label: 'percent', value: 'percent' },
  { label: 'second', value: 'second' },
  { label: 'avatar', value: 'avatar' },
  { label: 'code', value: 'code' },
  { label: 'switch', value: 'switch' },
  { label: 'fromNow', value: 'fromNow' },
  { label: 'image', value: 'image' },
  { label: 'jsonCode', value: 'jsonCode' },
  { label: 'color', value: 'color' },
];

type SchemaItem = {
  title: string,
  valueType: string,
  dataIndex: string,
};

const INIT_VALUES = [
  { title: 'Index', valueType: 'indexBorder', dataIndex: 'index' },
  {
    title: 'Enterprise',
    valueType: 'text',
    dataIndex: 'name',
  },
  { title: 'Company', valueType: 'text', dataIndex: 'authCompany' },
];

const columns: ColumnItemList<SchemaItem> = [
  {
    title: 'Title',
    dataIndex: 'title',
    type: 'input',
  },
  {
    title: 'ValueType',
    dataIndex: 'valueType',
    type: 'select',
    options: tableColumnValueOptions,
  },
  {
    title: 'DataIndex',
    dataIndex: 'dataIndex',
    type: 'select',
  },
];

export default () => {
  const [value, setValue] = useState(INIT_VALUES);

  return (
    <ColumnList
      columns={columns}
      value={value}
      onChange={(values) => {
        setValue(values);
        console.log('onChange', values);
      }}
    />
  );
};
`,paraId:4,tocIndex:2}]},20649:function(o,t,e){e.r(t),e.d(t,{texts:function(){return n}});const n=[{value:"In the mature year of 2023, why are we launching ProEditor?",paraId:0,tocIndex:0},{value:"In the current state where antd and ProComponents are so mature, the efficiency of frontend development is ten or even a hundred times faster than before, and the user experience has also been greatly improved. Does this mean that there is nothing left to do in the current component libraries?",paraId:1,tocIndex:1},{value:"If we carefully analyze the components in these libraries, they mostly focus on content display and lightweight editing, with few components involving relatively complex editing. A typical example is file operations in an operating system, involving multiple input modalities (keyboard, mouse) and multiple interaction methods (box selection, right-click menu, shortcuts, etc.).",paraId:2,tocIndex:1},{value:`We have discussed why such components are not included in antd and ProComponents, and the conclusion is: "It's relatively niche, costly, and not suitable for inclusion after weighing the options." Indeed, "editing" in the frontend is a relatively niche area with generally higher development costs. If you don't encounter it, it's fine, but once you do, there's no escaping a massive amount of code development. Most designers have not delved deeply into the "editing" scenario, and the components they create often do not provide an ideal user experience.`,paraId:3,tocIndex:1},{value:`An overview often lacks a tangible feel, so let's discuss a complex "editing" component with an example. For instance, if you want to implement a "sortable list" component like ColumnList, it involves the following complexities:`,paraId:4,tocIndex:2},{value:"Basic add, delete, and state management",paraId:5,tocIndex:2},{value:": It needs to support basic item addition and deletion, handle user click events to add or delete list items, update list data, etc., which is much more complex than displaying a list;",paraId:5,tocIndex:2},{value:"Drag-and-drop sorting logic",paraId:5,tocIndex:2},{value:": Simple drag-and-drop sorting requires handling user drag events, calculating the drag position, updating the list order, and handling the state of the sorted data, all of which require complex logic and code implementation that can overwhelm developers;",paraId:5,tocIndex:2},{value:"Drag-and-drop interaction indicators",paraId:5,tocIndex:2},{value:": When a user drags a list item, visual indicators are often needed, such as highlighting the drag position or displaying an overlay during the drag-and-drop process. These indicators also require additional code implementation; otherwise, the user's drag-and-drop experience will be poor. You may handle 1 and 2, but this one could be a stumbling block;",paraId:5,tocIndex:2},{value:"Controlled and uncontrolled modes",paraId:5,tocIndex:2},{value:": As a component, it is ideal to support both controlled and uncontrolled modes. In addition to 1, 2, and 3, you also need to consider how to simultaneously support controlled and uncontrolled modes. It's enough to make your head spin, isn't it?",paraId:5,tocIndex:2},{value:"Component extensibility",paraId:5,tocIndex:2},{value:": As a generic component, it definitely needs corresponding custom solutions to provide feasibility for integrating various business scenarios. The significant difference between editing components and display components lies in the need for not only display extensibility but also editing capability extensibility (atomic data editing).",paraId:5,tocIndex:2},{value:"In addition to the component level, there are many atomic operational capabilities that the current frontend has not systematically addressed. For example, shortcuts, switching focus with arrow keys, simultaneous keyboard and mouse selection (shift for multiple selection, cmd for copy), undo and redo, mouse box selection, etc.",paraId:6,tocIndex:3},{value:'The user interaction inputs mentioned above are fundamental in "operating systems" and most productivity tools (document suites, code editors, Sketch, PS), but in the "one-size-fits-all" Web, they are considered "luxury" capabilities.',paraId:7,tocIndex:3},{value:'We hope that ProEditor will become a foundational library similar to antd in the "editing" domain, allowing frontend developers to quickly and easily implement complex interactive components with excellent default user experience. This is also the reason why this component library is called "ProEditor."',paraId:8,tocIndex:4},{value:"To achieve the above goals, we have established the following principles:",paraId:9,tocIndex:4},{value:"Natural editing",paraId:10,tocIndex:4},{value:": Support the most natural user interactions, including but not limited to mouse multi-selection, deselection, and shortcuts;",paraId:10,tocIndex:4},{value:"Flexible and open",paraId:10,tocIndex:4},{value:": All capabilities support atomic output, including but not limited to components, hooks, utility functions, etc.;",paraId:10,tocIndex:4},{value:"Default usability",paraId:10,tocIndex:4},{value:": Go further on the basis of antd's basic components to achieve default usability in terms of user interaction.",paraId:10,tocIndex:4},{value:"If your scenario is:",paraId:11,tocIndex:6},{value:"Official website homepage, documentation page",paraId:12,tocIndex:6},{value:": These scenarios generally do not involve any heavy user interaction operations, so ProEditor is not suitable;",paraId:12,tocIndex:6},{value:"Standard CRUD scenarios in the middle and back office",paraId:12,tocIndex:6},{value:": For these scenarios, consider using ",paraId:12,tocIndex:6},{value:"antd",paraId:12,tocIndex:6},{value:" and ",paraId:12,tocIndex:6},{value:"ProComponents",paraId:12,tocIndex:6},{value:" directly;",paraId:12,tocIndex:6},{value:"The technology stack is not React",paraId:12,tocIndex:6},{value:": For these scenarios, consider the relevant components in your technology stack. ProEditor is only focused on the React ecosystem.",paraId:12,tocIndex:6},{value:"Scenarios involving many complex editing operations",paraId:13,tocIndex:7},{value:": For example, various canvas and editor scenarios, you can use some atomic components in ProEditor (e.g., DraggablePanel) to improve your development efficiency;",paraId:13,tocIndex:7},{value:"Component visual editing scenarios",paraId:13,tocIndex:7},{value:": For example, if you need a component visual editor similar to ",paraId:13,tocIndex:7},{value:"Kitchen Smart Table",paraId:13,tocIndex:7},{value:", you can try using the component assembly paradigm provided by ProEditor to implement it.",paraId:13,tocIndex:7}]},66484:function(o,t,e){e.r(t),e.d(t,{texts:function(){return n}});const n=[]},71362:function(o,t,e){e.r(t),e.d(t,{texts:function(){return n}});const n=[{value:"The relationship between high code (props) and low code (configurator) is not a simple one-to-one mapping, but an organic organizational form that we call the Puppet Model. Props are like the strings of a puppet, and the configurator is the puppet's controller. Their relationship is illustrated in the following diagram:",paraId:0,tocIndex:1},{value:"A structure that is easy to use for the configurator is probably not one-to-one with the component's props. Therefore, we will specifically design a separate data model for the configurator, which we call config.",paraId:1,tocIndex:1},{value:"We call the properties of the code props, and the properties of the configurator config. The description of the configurator property definition is called schema. The relationship between them is illustrated in the following diagram:",paraId:2,tocIndex:2},{value:" ",paraId:3,tocIndex:2},{value:"Schema (config): Metadata given to the configurator editor",paraId:4,tocIndex:2},{value:"Emitter (config -> props): Converts the configurator to code properties",paraId:4,tocIndex:2},{value:"Parser (props -> config): Parses props into config",paraId:4,tocIndex:2},{value:"Based on this data model, we can theoretically achieve bidirectional conversion between code and assembler.",paraId:5,tocIndex:2},{value:"The code declaration reflecting the above metadata model is as follows:",paraId:6,tocIndex:3},{value:`const model: Model<Config, Props> = {
  key: '',
  schema: (config: Config, store: ProEditorStore): Schema => {},
  parser: (props: Props): Config => {},
  emitter: (config: Config, env: EmmiterEnv): Props => {},
};
`,paraId:7,tocIndex:3},{value:"The above Model reflects the lifecycle of component data flow. Next, let's introduce the description model of component asset metadata, ComponentAssets.",paraId:8,tocIndex:4},{value:`export const tableAssetParams = {
  id: 'table',
  // ...

  // Input model
  models: [tableModel, dataModel, toolbarModel],
};
`,paraId:9,tocIndex:4}]},38178:function(o,t,e){e.r(t),e.d(t,{texts:function(){return n}});const n=[{value:"In multi-user collaboration, we can divide data models into two major categories based on the usage of the data:",paraId:0,tocIndex:0},{value:"File Data",paraId:1,tocIndex:0},{value:": Unique data instances (everyone sees the same file data)",paraId:1,tocIndex:0},{value:"Interface Views",paraId:1,tocIndex:0},{value:": Each person sees their own default view, but when a user chooses to follow someone else, the view completely follows the other person's view",paraId:1,tocIndex:0},{value:"The data flow of ProEditor contains two types:",paraId:2,tocIndex:1},{value:"Container type, one and only one: ",paraId:3,tocIndex:1},{value:"ProEditorStore",paraId:3,tocIndex:1},{value:";",paraId:3,tocIndex:1},{value:"Component type, which will be expanded according to future extension situations, currently including ",paraId:3,tocIndex:1},{value:"ProTableStore",paraId:3,tocIndex:1},{value:" and ",paraId:3,tocIndex:1},{value:"ProLayoutStore",paraId:3,tocIndex:1},{value:", and may be expanded to include ",paraId:3,tocIndex:1},{value:"ProFromStore",paraId:3,tocIndex:1},{value:", ",paraId:3,tocIndex:1},{value:"ProChartStore",paraId:3,tocIndex:1},{value:", etc. in the future;",paraId:3,tocIndex:1},{value:"The container class Store only stores Editor-related states, such as:",paraId:4,tocIndex:1},{value:"Developer/designer mode;",paraId:5,tocIndex:1},{value:"Switching between canvas and code;",paraId:5,tocIndex:1},{value:"Activation information for the current canvas interaction;",paraId:5,tocIndex:1},{value:"Currently loaded ComponentAsset instances;",paraId:5,tocIndex:1},{value:"...",paraId:5,tocIndex:1},{value:"The component class Store will contain specific component configurations, such as:",paraId:6,tocIndex:1},{value:"Component configuration information;",paraId:7,tocIndex:1},{value:"Tabs for switching component panels;",paraId:7,tocIndex:1},{value:"Previewer collapse status;",paraId:7,tocIndex:1},{value:"...",paraId:7,tocIndex:1},{value:"The purpose of this separation is to separate the focus points, making it easier for future extensions.",paraId:8,tocIndex:1},{value:"The data flow connection methods are explained from the container layer and the component layer.",paraId:9,tocIndex:2},{value:"The core function of the container layer is to schedule the communication between the component layer data and external data sources.",paraId:10,tocIndex:3},{value:"Since ProEditor itself is a component, it must support both controlled and uncontrolled modes, which brings great challenges to the architecture of the data flow.",paraId:11,tocIndex:3},{value:"Due to the complexity of the editor's information processing, in the uncontrolled mode, it is fine for the data to be handled entirely by the component itself. But once it comes to the controlled mode, how to synchronize the internal and external states to ensure data consistency, and make it more flexible for component consumers to use, becomes a headache.",paraId:12,tocIndex:3},{value:"For example, the ",paraId:13,tocIndex:3},{value:"ProTableStore",paraId:13,tocIndex:3},{value:" has over 20 dispatch methods for the columns data. If these methods are directly exposed to external developers for consumption, external developers may be overwhelmed.",paraId:13,tocIndex:3},{value:"In the previous process of troubleshooting, if using useEffect to listen for external changes and setState, and then onChange for internal state changes, it is very easy to cause a loop of repeated rendering, which is a heavy burden on developers' mental workload.",paraId:14,tocIndex:3},{value:"The following code can be used in relatively simple scenarios, but when we have 10+ operation methods and need to use a reducer, the data flow processing will become a mess.",paraId:15,tocIndex:3},{value:`import { useEffect, useState } from 'react';

const useStore = (value, onChange) => {
  const [innerValue, setValue] = useState('');

  useEffect(() => {
    setValue(value);
  }, [value]);

  const innerSetState = (value) => {
    setValue(value);

    onChange(value);
  };
};
`,paraId:16,tocIndex:3},{value:"Therefore, for the final development, the strategy is to use the internal data source as the SoT, and synchronize the external data source into the internal data source according to the situation to achieve state management.",paraId:17,tocIndex:3},{value:"The specific development strategy is as follows:",paraId:18,tocIndex:3},{value:"First, as with normal development, create a top-level data source in the Wrapper and pass it down to the child components;",paraId:19,tocIndex:3},{value:"Develop the component itself as an uncontrolled component (App), without considering any external controlled values;",paraId:19,tocIndex:3},{value:"Use the ",paraId:19,tocIndex:3},{value:"StoreUpdater",paraId:19,tocIndex:3},{value:" component as a ",paraId:19,tocIndex:3},{value:"glue layer",paraId:19,tocIndex:3},{value:" to isolate the internal application (",paraId:19,tocIndex:3},{value:"App",paraId:19,tocIndex:3},{value:") from the external data source (",paraId:19,tocIndex:3},{value:"config",paraId:19,tocIndex:3},{value:", ",paraId:19,tocIndex:3},{value:"onConfigChange",paraId:19,tocIndex:3},{value:", ",paraId:19,tocIndex:3},{value:"defaultConfig",paraId:19,tocIndex:3},{value:", etc.);",paraId:19,tocIndex:3},{value:"Determine the methods and objects in the ",paraId:19,tocIndex:3},{value:"store",paraId:19,tocIndex:3},{value:" that need data interaction, add ",paraId:19,tocIndex:3},{value:"OnChange",paraId:19,tocIndex:3},{value:" in the ",paraId:19,tocIndex:3},{value:"internalUpdate",paraId:19,tocIndex:3},{value:" method, and synchronize the external data source to the internal using the ",paraId:19,tocIndex:3},{value:"syncOutSource",paraId:19,tocIndex:3},{value:" method;",paraId:19,tocIndex:3},{value:`export const Container: FC = (props) => {
  const {
    config,
    onConfigChange,
    defaultConfig,

    ...res
  } = props;

  return (
    <Wrapper>
      <App {...res} />
      <StoreUpdater config={config} defaultConfig={defaultConfig} onConfigChange={onConfigChange} />
    </Wrapper>
  );
};
`,paraId:20,tocIndex:3}]},16495:function(o,t,e){e.r(t),e.d(t,{texts:function(){return n}});const n=[{value:"ProBuilder can quickly build the configuration interface for components.",paraId:0,tocIndex:0},{value:"Setting ",paraId:1,tocIndex:4},{value:"editorAwareness",paraId:1,tocIndex:4},{value:" to a controlled state can control the current view state.",paraId:1,tocIndex:4}]},23794:function(o,t,e){e.r(t),e.d(t,{texts:function(){return n}});const n=[{value:"If you:",paraId:0,tocIndex:0},{value:"Want to use ",paraId:1,tocIndex:0},{value:"useProEditor",paraId:1,tocIndex:0},{value:", ",paraId:1,tocIndex:0},{value:"useConfig",paraId:1,tocIndex:0},{value:", ",paraId:1,tocIndex:0},{value:"useViewport",paraId:1,tocIndex:0},{value:", and other ProEditor hooks in components that are not direct children of the ProEditor component;",paraId:1,tocIndex:0},{value:"Have multiple instances of ProEditor on the page;",paraId:1,tocIndex:0},{value:"Need to access internal state or use data methods provided by ProEditor in components that are not direct children of the ProEditor component.",paraId:1,tocIndex:0},{value:"Then you need to wrap the relevant application components with ",paraId:2,tocIndex:0},{value:"ProBuilderProvider",paraId:2,tocIndex:0},{value:".",paraId:2,tocIndex:0}]},71178:function(o,t,e){e.r(t),e.d(t,{texts:function(){return n}});const n=[{value:"This module implements the basic functionality of real-time collaboration among multiple users.",paraId:0,tocIndex:0},{value:"Data synchronization (using yjs-zustand middleware)",paraId:1,tocIndex:0},{value:"Collaboration awareness (Avatar, Cursor components)",paraId:1,tocIndex:0},{value:"It reuses the ",paraId:2,tocIndex:3},{value:"zustand-middleware-yjs",paraId:2,tocIndex:3},{value:" middleware.",paraId:2,tocIndex:3},{value:"By designing a suitable data synchronization layer structure for the ProEditor container, it can possess the capability for multi-user collaboration.",paraId:3,tocIndex:3},{value:"The zustand-middleware-yjs does not provide the Awareness capability in yjs. Therefore, common functions in multi-user collaboration such as user status and pointer display need to be implemented independently.",paraId:4,tocIndex:4},{value:"After implementing multi-user collaboration based on YJS, the history records are a native feature. However, presenting this large amount of data to users in a suitable manner requires the design of a reasonable interaction solution.",paraId:5,tocIndex:5},{value:"Offline caching is one of the core principles of Local First.",paraId:6,tocIndex:6}]},7444:function(o,t,e){e.r(t),e.d(t,{texts:function(){return n}});const n=[{value:"This method can obtain the perceptual view state of assets in the editor.",paraId:0},{value:`import { usePresenceAsset } from '@ant-design/pro-editor';

const getPresenceAsset = () => {
  const [presence, setPresence] = usePresenceAsset();

  useEffect(() => {
    console.log(setPresence);
  }, [presence]);

  return null;
};
`,paraId:1},{value:"Note: This hook can only be used within components wrapped by ",paraId:2},{value:"ProBuilderProvider",paraId:2},{value:", or within the child components of the ",paraId:2},{value:"<ProEditor />",paraId:2},{value:" component.",paraId:2}]},6633:function(o,t,e){e.r(t),e.d(t,{texts:function(){return n}});const n=[{value:"This method is a React Hook used to obtain the instance object of the ProEditor editor. Here is how to use it:",paraId:0},{value:`import { useProEditor } from '@ant-design/pro-editor';

// Call the useProEditor method in the component:
const MyComponent = () => {
  const editor = useProEditor();

  // You can use the editor object here to access the properties and methods of ProEditor
  // For example:
  const presenceEditor = editor.getPresenceEditor();
  const viewport = editor.getViewport();
  const config = editor.getConfig();
  const props = editor.getProps();

  return <div>My Component</div>;
};
`,paraId:1},{value:"Note: This hook can only be used in components wrapped by ",paraId:2},{value:"ProBuilderProvider",paraId:2},{value:", or in the child components of the ",paraId:2},{value:"<ProEditor />",paraId:2},{value:" component.",paraId:2},{value:"You can use the editor object to access the properties and methods of ProEditor:",paraId:3},{value:"getPresenceEditor",paraId:4},{value:": Get the presenceEditor object of the current ProEditor;",paraId:4},{value:"getViewport",paraId:5},{value:": Get the ",paraId:5},{value:"viewport",paraId:5},{value:" of the current ProEditor;",paraId:5},{value:"getConfig",paraId:6},{value:": Get the config of the current ProEditor;",paraId:6},{value:"getProps",paraId:7},{value:": Get the props of the current ProEditor.",paraId:7},{value:"Note: The objects returned by the above methods are always the latest values, meaning that each call will return the most up-to-date value.",paraId:8}]}}]);
